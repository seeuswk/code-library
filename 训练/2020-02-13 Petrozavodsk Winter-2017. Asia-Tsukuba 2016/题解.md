# A. Rearranging a Sequence
简单题
# B. Quality of Check Digits
简单题
# C. Distribution Center
简单题，能到每个终点的起点是一段区间，递推左右端点
# D. Hidden Anagrams
简单题，暴力+哈希
# E. Infallibly Crack Perplexing Cryptarithm
一共只有8个字符，由于字母和字符应该一一对应，暴力枚举，得到表达式，直接写paser计算即可。
# F. Three Kingdoms of Bourdelot
本题的主要难度在于读题，实际上每份档案里面每行描述了x和y是否存在祖先和子孙关系，一份档案描述的关系要么全都存在要么全都不存在。想知道对于给定的p，q是否有可能p是q的祖先。我们把关系用有向边表示，如果图中没有环，这样的关系就是合法的。首先对于p，q，如果没有任何一份档案直接（必须是直接）描述pq的关系，那么就可以认为所有档案都是表示否定的，这样一定成立。如果有描述pq关系的档案，那这份档案必然为肯定的，所有这份档案可能存在的关系必须成立。注意到不同的人不超过300个，暴力维护两个人之间是否有祖先关系，每次有一个关系发生变化，就检查是否有新的档案变成必须是肯定的。直到所有肯定的档案确定下来，剩下的都是否定的，检查是否有环即可。
# G.  Placing Medals on Binary Tree
实际上就是求$\sum \frac{1}{2^x}$是否大于1，动态开点的线段树维护二进制下的每一位，每次加入一个数就是在某一位上加1，如果变成了2就进位。
# H. Animal Companion in Maze
首先需要注意是不能连续走相同的边，而不是不能回到上次到达的点。双向边在拆成两条单向边时需要打标记。直接计算从每个点出发至多走多少步以及走了哪条边，同时也需要记录次多值，这样就可以在搜索中计算每个值了，每次搜索到一个点，计算当前答案，只去搜索所有非来边，这是为了防止直接搜索到同一条边组成的环。这样做的话，每条边要标记是否被搜索过，每条边只能被搜索一次，而每个点至多被搜索两次，而第二次搜索时至多只有一条边尚未被访问过。搜索过程中一旦遇到环，就代表答案是infinite。
# I. Skinny Polygon
构造题。如果$gcd(x,y)$小于根号，选以左下-右上对角线为底边的最小的三角形，如果$gcd(x,y)$大于根号，选$(0,0)(x-1,y)(\frac{x}{gcd(x,y)},\frac{y}{gcd(x,y)})(x,y-1)$。
# J. Skinny Polygon
计算几何题。首先圆心一定在多边形内。然后答案关于圆心的位置是凸函数。在多边形内三分套三分。
# K. Black and White Boxes
超实数博弈
