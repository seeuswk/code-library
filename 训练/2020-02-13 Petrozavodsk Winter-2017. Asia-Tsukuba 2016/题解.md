# E. Infallibly Crack Perplexing Cryptarithm
一共只有8个字符，由于字母和字符应该一一对应，暴力枚举，得到表达式，直接写paser计算即可。
# G.  Placing Medals on Binary Tree
实际上就是求$\sum \frac{1}{2^x}$是否大于1，动态开点的线段树维护二进制下的每一位，每次加入一个数就是在某一位上加1，如果变成了2就进位。
# H. Animal Companion in Maze
首先需要注意是不能连续走相同的边，而不是不能回到上次到达的点。双向边在拆成两条单向边时需要打标记。直接计算从每个点出发至多走多少步以及走了哪条边，同时也需要记录次多值，这样就可以在搜索中计算每个值了，每次搜索到一个点，计算当前答案，只去搜索所有非来边，这是为了防止直接搜索到同一条边组成的环。这样做的话，每条边要标记是否被搜索过，每条边只能被搜索一次，而每个点至多被搜索两次，而第二次搜索时至多只有一条边尚未被访问过。搜索过程中一旦遇到环，就代表答案是infinite。
# I. Skinny Polygon
构造题。如果x=y的时候，选(0,0)(x-1,y)(1,1)(x,y-1)，x!=y的时候也是类似的形状，只不过要把(1,1)换成斜率比较接近的y/x的点，调整一下即可。