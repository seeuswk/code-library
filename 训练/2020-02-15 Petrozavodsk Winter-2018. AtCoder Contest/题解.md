# D. Knapsack and Queries
对于在背包中的东西，按weight排序，每次删除只会删除最小的那个，所以我们按照2^n从小到大分块，每加入一个，每个块维护的背包应该增加一个东西，当删除时，最靠前的块如果大小多于1就应该重构。

# E. XorTree
把边权变成点权，每个点的点权就是所有相连的边的权值的异或和，边权全为0等价于点权全为0。每次修改实际上只修改了两个端点的点权。最优情况一点是操作两个权值相等的点，剩下不同的点不超过16个，dp一下即可。

# F. Antennas On Tree
首先所有的监视器一定会放在叶子节点上，这样一定最优，接下来的问题就是需要放几个叶子，可以发现，图中度数为2的点都影响答案，可以去掉，剩下的所有与叶子直接相连的度数多于2的节点，他的一个叶子可以不用监视器。

# H. Generalized Insertion Sort 
考虑是一个链的时候应该怎么做，根据题目标题，就是插入排序法，我们可以把这个链看做一个插入序列，每次我们把头部的一个元素插入到链尾部已经排好序的序列的正确位置。对于树，很容易想到可以树链剖分，对于链分层，每层的链互不影响这样不同的链就可以同时做。注意每次要把有用的元素“挤”上来。
