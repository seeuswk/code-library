# C. Clique Festival
对于每个团，新建一个虚点连接所有点。先预处理k个虚点之间的最短路，两两连接k个虚点，那么对于每个点u，到另一个点v的最短路只有u-虚点-v或者u-虚点-虚点-v。枚举起点u，到其它所有点的不同最短距离只有不超过k种，每个团对应1种，取k种距离排序，依次计算每种距离的可以到达的点但不能被前面的方案到达的点的个数。例如排序后分别是团c_1,c_2...c_k,依次计算被在c_i中但不在c_1,c_2...c_{i-1}中的点的个数。需要预处理子集数量。
# F. Dominating Subarray
一个subarray是k-dominating的，如果它在中间（既不是最左边的也不是最右边的）那么它的所有数必须相等，且是最大值。如果它在最左边或者最右边，它一定单调不增或单调不减，而且除了k个数之外其它数必须更小。注意k可能等于n，这样自己本身无论是什么样都是k-dominating的。
# H. Galactic Governments 
因为要求字典序最小，逐维二分，容斥高维立方体并判断二分出来的立方体是否被完全覆盖。注意容斥需要计算的最大值最小值可以预处理。
# I. Multiplication
随机输入一些不同的奇数a1,a2...。对于返回的结果b，任取$a_i$，有1/2的概率返回的数中存在ai*x，随机取100个$a_i$，计算$x_{ij}=b_j*a_i^{-1}$，统计x出现的次数，按出现次数从大到小check是否成立。
#  J. Guess Two Strings
先判断是否两个串完全相同。如果两个串某一位不同，那这一位0和1的数量的差期望为0。
把每一位按0和1个数的差的绝对值从小到大排序，每次取一位，直接认为这一位上两个串不同，把这一位上是0的认为是s变化过来，是1的认为是由t变化而来，由于每一位错误率只有15%，剩下的每一位取众数得到s和t。注意有一定概率出错，一定要check最后是否成立，不成立的话换一位。
# K. Beautiful Tables 
首先注意到每一行每一列都应该是等差数列，所以只要确定左上角的2*2就知道了所有数，所以“自由度”只有4。设四个未知量，对于所有填上了数的位置，列方程，高斯消元求解即可。（直接列方程精度可能不够）